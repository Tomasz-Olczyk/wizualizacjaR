---
title: "Wizualizacja czasu"
author: "Tomasz Olczyk"
output:
  html_document:
    df_print: paged
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

poniższy kod działa na macu

```{r include=FALSE}

#Sys.setlocale("LC_TIME","pl_PL.UTF-8")

```

## Timeline - oś czasu z wykorzystanie geom_segment

Według Dana Roama autora ksiażki "Narysuj swoje myśli" oś czasu jest modelem wizualnym ilustrującym odpowiedź na pytanie "kiedy" [@roam2010]. Najprościej stworzyć *timeline* używając funkcji `geom_segment()` ggplot2.


### Biblioteki

```{r}

library(tidyverse)

```



### Dane - Sapkowski i Martin

Użyjemy danych dotyczących dat publikacji i liczby słów w książkach z sag A. Sapkowskiego i G.R.R. Martina. 

```{r}


fantasy <- read_csv("https://raw.githubusercontent.com/Tomasz-Olczyk/wizualizacjaR/main/czas/fantasy.csv")


```


```{r}

head(fantasy)


```


Poniższy wykres jest połączeniem wykresu [lizakowego](https://r-graph-gallery.com/lollipop-plot.html)
(lollypop chart) z osią czasu. Lizaki - słupki a właściwie odcinki zakończone punktem - oznaczać będą daty kolejnych książek


```{r}

fantasy %>% filter(author == "Martin") %>% 
  # dodaje zmienną disloc, której użyję do mapowania wysokości lizaków
  mutate(disloc = c(0.5, 1, -0.5, -1, 2, 1.5, 0.5)) %>%
ggplot() +
    geom_segment(aes(x = rok, 
                     y = disloc, 
                     xend = rok), 
                 yend = 0) + 
  #rysuję oś czasu
    geom_segment(aes(x = 1990,
                     y = 0, 
                     xend = 2020,
                     yend = 0),
                 arrow = arrow(length = unit(x = 0.2,units = 'cm'),type = 'closed')) +
    geom_text(aes(x = rok,
                  y = disloc,
                  label = title), 
              hjust = 1.0,vjust = 1.0,
              size  = 4) +
    geom_point(aes(x = rok,
                   y = disloc)) +
  # kontroluję etykiety na skali ręcznie wybierając tylko lata publikacji książek
    scale_x_continuous(breaks = c(1996, 1999, 2000, 2005, 2011)) +
    theme_minimal() +
    theme(axis.title.x = element_blank(), #usuwa tytuł
          axis.title.y = element_blank(),
          axis.text.y = element_blank(),
          text = element_text(size = 10))
```


Etykiety na skali można także wybrać na podstawie danych:


```{r}

sapkowski <- fantasy %>% 
  filter(author == "Sapkowski") %>% 
  mutate(disloc = c(0.5, 1, -0.5, -1, 2)) #mniej punktów bo saga Sapkowskiego jest krótsza


```



```{r}
ggplot(sapkowski) +
    geom_segment(aes(x = rok, 
                     y = disloc, 
                     xend = rok), 
                 yend = 0) + 
  #rysuję oś czasu
    geom_segment(aes(x = 1990,
                     y = 0, 
                     xend = 2003, #skracam oś czasu bo ostatnia książka jest z 1999
                     yend = 0),
                 arrow = arrow(length = unit(x = 0.2,units = 'cm'),type = 'closed')) +
    geom_text(aes(x = rok,
                  y = disloc,
                  label = title), 
              hjust = 1.0,
              vjust = 1.0,
              size  = 4) +
    geom_point(aes(x = rok,
                   y = disloc)) +
  #kontroluje etykiety na skali ręcznie wybierając tylko lata publikacji książek wykorzystując dane w ramce
    scale_x_continuous(breaks = sapkowski$rok) +
    theme_minimal() +
    theme(axis.title.x = element_blank(), #usuwa tytuł
          axis.title.y = element_blank(),
          axis.text.y = element_blank(),
          text = element_text(size = 10))

```




### Zadanie




```{r, fig.width = 20, fig.height= 5}

fantasy %>% 
ggplot() +
    geom_segment(aes(x = rok, y = words,xend = rok, color = author),yend = 0) + # data = data trzeba ustawić globalnie
    geom_segment(aes(x = 1990,
                     y = 0,
                     xend = 2020,
                     yend = 0), 
                 arrow = arrow(length = unit(x = 0.2,
                                             units = 'cm'),
                               type = 'closed')) +
    geom_text(aes(x = rok,y = words,
                  label = title),
              hjust = 1.0,
              vjust = 1.0,
              size  = 4) +
    geom_point(aes(x = rok,
                   y = words,
                   color = author)) +
    theme_minimal() +
    theme(axis.title.x = element_blank(), # element_blank() usuwa dany element motywu
          axis.title.y = element_blank(),
          axis.text.y = element_blank(),
          text = element_text(size = 10))
```


```{r fig.width = 20, fig.height= 5}

fantasy %>% 
  ggplot() +
  geom_segment(aes(x = rok, y = words,xend = rok),yend = 0) + # data = data trzeba ustawić globalnie
  geom_segment(aes(x = 1993,y = 0,xend = 2012,yend = 0),
               arrow = arrow(length = unit(x = 0.2,units = 'cm'),type = 'closed')) +
  geom_text(aes(x = rok,y = words,label = title),   hjust = 0.5,vjust = - 0.5, size  = 4) +
  geom_point(aes(x = rok,
                 y = words)) +
  scale_x_continuous(breaks = c(1994, 1995, 1996, 1997, 1999, 2000,2005, 2011)) +
  scale_y_continuous(limits = c(0, 450000)) +
  theme_bw() +
  labs(y = "słowa") +
  theme(axis.title.x = element_blank(), #usuwa podpis na osi x
       #axis.title.y = element_blank(),
        axis.text.y = element_blank(), # usuwa tekst etykiet na osi y
        text = element_text(size = 15)) +
  facet_wrap(~author, nrow =2)
```

## Wykres Gantta z wykorzystaniem geom_segment


Prosty przykład ramki danych z datami w formie znakowej.

```{r}
timeline_data <- data.frame(event = c("Event 1", "Event 2"),
                            start = c("2020-06-06", "2020-10-01"), 
                            end   = c("2020-10-01", "2020-12-31"),
                            group = "My Events")
                            

```


Na poniższym wykresie widać problem z właściwą interpretacją dat w formie napisów:

```{r}

timeline_data %>%
  ggplot() +
  geom_segment(aes(y = event, #potrzebujemy esetyk y, yend i analogizni z x
                   xend = end, 
                   x= start,
                   yend = event)) +
  theme_bw()

```


Dlatego zamienimy napisy na daty funkcją as.Date:

```{r}
timeline_data %>%
  mutate(start = as.Date(start),
         end = as.Date(end)) %>%
 ggplot() +
  geom_segment(aes(y = event, 
                   xend = end, 
                   x= start, 
                   yend = event)) +
  theme_bw()
```

Ponieważ w moim systeme daty ustawione są na amerykańskie zmieniam ustawienie na polskie.

Poniższy kod działa tylko na mac os i ma sens jedynie gdy mamy niepolskie ustawienia  a chcemy zmienić na polskie

```{r}
Sys.setlocale("LC_TIME", "pl_PL.UTF-8")
```


Ten sam wykres będzie wyglądał inaczej.


```{r}
timeline_data %>%
  mutate(start = as.Date(start),
         end = as.Date(end)) %>%
 ggplot() +
  geom_segment(aes(y = event, 
                   xend = end, 
                   x= start, 
                   yend = event)) +
  theme_bw()
```


Gantt w jednej linii

```{r}

timeline_data %>%
  mutate(start = as.Date(start),
         end = as.Date(end)) %>%
  ggplot() +
  geom_segment(aes(y = group, 
                   xend = end, 
                   x= start, 
                   yend = group,
                   colour = event)) +
  scale_x_date() +
  theme_bw()



```




## Wykres Gantta rządów III RP


Dane dotyczące długości trwania poszczególnych rządów w IIIRP za wikipedią:

```{r}

premierzyIIIRP <- read_csv("https://raw.githubusercontent.com/Tomasz-Olczyk/wizualizacjaR/main/czas/premierzyIIIRP.csv")

```



```{r}
View(premierzyIIIRP)
```

Jak widać w ostatniej komórce brakuje daty.

Dla uniknięcia problemów z rysowaniem linii można uzupełnić końcową komórkę w zmiennej end datą systemową funkcją Sys.Date, wewnątrz funkcji ymd z biblioteki lubridate. Komórka znajduje się w 7 kolumnie, w 22 wierszu więc robimy to tak:


```{r}

premierzyIIIRP[22,7] <- lubridate::ymd(Sys.Date())

```


### z wykorzystanim geom_segment

```{r}

ggplot(premierzyIIIRP) +
  geom_segment(aes(y = stronnictwo, 
                   xend = end, 
                   x= start,
                   yend = stronnictwo, 
                   colour = stronnictwo)) +
  scale_x_date() +
  theme_bw()

```



Uporządkujmy wykorzystując funkcję reorder:


```{r}

ggplot(premierzyIIIRP) +
  geom_segment(aes(y = reorder(stronnictwo, start), 
                   xend = end, 
                   x= start,
                   yend = stronnictwo, 
                   colour = stronnictwo)) +
  scale_x_date() +
  theme_bw()

```


Ustalmy etykiety na osi y na zakończenia kadencji (premierzyIIIRP$end).

```{r}

ggplot(premierzyIIIRP) +
  geom_segment(aes(y = reorder(stronnictwo, start), 
                   xend = end, 
                   x= start,
                   yend = stronnictwo, 
                   colour = stronnictwo)) +
  scale_x_date(breaks = (premierzyIIIRP$end), # ustawiamy daty na osi x na koniec danego rządu
               date_labels = "%Y") + #date_labels ustawione na rok
  theme_bw() +
  guides(colour = "none") # wyłączamy legendę

```

To nie jest dobre rozwiązanie bo daty się nakładają


Dlatego stworzymy wektor z unikalnymi datami rocznymi funkcjami unique i year.

```{r}

kadencje <- unique(year(premierzyIIIRP$start))

```


Wektor który uzyskaliśmy ma format  numeryczny.


```{r}
class(kadencje)
```

Następnie zmienimy jego format na dat

```{r}

kadencje <- lubridate::ymd(kadencje, 
                                truncated = 2L)

```

```{r}
class(kadencje)
```


```{r}

plotly::ggplotly(ggplot(premierzyIIIRP) +
  geom_segment(aes(y = reorder(stronnictwo, start), 
                   xend = end, 
                   x= start,
                   yend = stronnictwo, 
                   colour = stronnictwo)) +
  scale_x_date(breaks = kadencje, 
               date_labels = "%Y") +
  theme_bw() +
    guides(colour = "none") 
)

```


```{r}

z <- ggplot(premierzyIIIRP) +
  geom_segment(aes(y = reorder(stronnictwo, start), 
                   xend = end, 
                   x= start,
                   yend = stronnictwo, 
                   colour = stronnictwo,
                   text = paste("",nazwisko,
                  "<br>",stronnictwo,
                  "<br>objęcie urzędu:",start,
                  "<br>złożenie urzędu:",end))) +
  scale_x_date(breaks = kadencje, 
               date_labels = "%Y") +
  theme_bw()

  

```



```{r}

plotly::ggplotly(z, tooltip = "text")

```


```{r}
y <- ggplot(premierzyIIIRP) +
  geom_segment(aes(y = reorder(stronnictwo, start), 
                   xend = end, 
                   x= start,
                   yend = stronnictwo, 
                   colour = stronnictwo,
                   text = paste("",nazwisko,
                  "<br>",stronnictwo,
                  "<br>objęcie urzędu:",start,
                  "<br>złożenie urzędu:",end)),
                  linewidth = 10) + # poszerzymy lini
  scale_x_date(breaks = kadencje, 
               date_labels = "%Y") +
  scale_color_brewer(palette = "Set3") +
  theme_bw()
```


```{r}
y
```


```{r}

plotly::ggplotly(y, tooltip = "text") # dodatmy tekst do argumntu tooltip

```


 
```{r}


library(scales)
library(lubridate)


```

## timeline z biblioteką timevis

```{r}
#install.packages("timevis")
```

```{r}

library(timevis)

```

```{r}

data <- data.frame(
  id      = 1:4,
  content = c("Item one", "Item two",
              "Ranged item", "Item four"),
  start   = c("2016-01-10", "2016-01-11",
              "2016-01-20", "2016-02-14 15:00:00"),
  end     = c(NA, NA, "2016-02-04", NA)
)

timevis(data)
```

```{r}
?timevis
```


## próba z timevis


```{r}

premierzyIIIRP %>%
  rename(content = nazwisko) %>%
  rename(group = stronnictwo) %>% #argument groups i soubgroups pakitu timevis
timevis()


```



## Kalendarz-mapa cieplna z wykorzystaniem geom_tile i facet_wrap

## Kalendarz z Oryxem

Użyjemy danych na temat sttrat sprzętu wojskowego w Ukrainie:

```{r }

oryx <- read.csv("https://raw.githubusercontent.com/Tomasz-Olczyk/testowe-repozytrium/main/oryx.csv")

```

zajrzyjmy do danych:

```{r}

glimpse(oryx)

```


`oryx$date` jest wektorem napisów a `oryx$change_3` liczb całkowitych z wartościami brakującymi

```{r}
oryx %>% 
  mutate(date = as.Date(date)) %>%
  complete(date = seq.Date(as.Date("2022-02-01"), #funkcja complete tworzy nowe obserwacje, funkcja seq.Date tworzy sekwencję dat
                           as.Date("2023-12-31"), 
                           by="day")) %>% 
  mutate(month = month(date, label = TRUE), 
         wday = wday(date, label = TRUE),
         day = day(date), 
         week = epiweek(date)) -> df2 #operator przypisania może działać także w drugą stronę
```

Epiweek - tydzień zaczyna się od niedzieli:

```{r}

?epiweek

```

uwaga zmiana na isoweek psuje mi wykres

```{r}
oryx %>% 
  mutate(date = as.Date(date)) %>%
  filter(date < "2023-01-01") %>%
  complete(date = seq.Date(as.Date("2022-02-01"), as.Date("2022-12-31"), by="day")) %>% 
  mutate(month = month(date, label = TRUE), 
         wday = wday(date, label = TRUE),
         day = day(date), 
         week = lubridate::epiweek(date)) -> df2 
```

Kolejność dni

```{r}
df2$wday <- factor(df2$wday, levels = c("pon", "wto", "śro", "czw", "ptk", "sob", "ndz"))
```

```{r}

(x <- df2 %>% 
  ggplot(aes(x = wday, y = week, text = paste('straty: ', change_3))) + 
  geom_tile(aes(fill = change_3), color = "black", size = .5) +
  geom_text(aes(label = day)) + 
  labs(title = "Sprzęt utracony na Ukrainie przez Rosjan - dane Oryx", 
       x = "", 
       y = "") + 
  scale_fill_continuous(low = "grey90", 
                       high = "black", 
                     name = "straty dzienne", 
                     na.value = 'white') +
  scale_x_discrete(position = "top") +
  scale_y_continuous(trans = "reverse") + 
  scale_color_manual(values = c("black", "grey")) + 
  facet_wrap(~month, scales="free_y") +
     theme_grey() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank())) +
    guides(color = "none") 

```

```{r}

library(plotly)

```

```{r, eval = FALSE}
ggplotly(x, tooltip = "text")
```

## Kalendarz mapa-cieplna a'la github

dodam kolumnę latami

```{r}
oryx %>% 
  mutate(date = as.Date(date)) %>%
  #usunę filtrowani na roku
  #filter(date < "2023-01-01") %>%
  complete(date = seq.Date(as.Date("2022-01-01"), as.Date("2023-12-31"), by="day")) %>% 
  mutate(year = year(date),
         month = month(date, label = TRUE),
         months = month(date, label = FALSE),
         wday = wday(date, label = TRUE),
         day = day(date), 
         week = lubridate::isoweek(date)) -> df2 
```

```{r}

df2$wday <- factor(df2$wday, levels = c("pon", "wto", "śro", "czw", "ptk", "sob", "ndz"))
```

```{r}
ggplot(df2, aes(y = fct_rev(wday), x= week, fill = change_3)) +
  geom_tile(width =7, height = 1, colour = "white") 
  

```

```{r}

ggplot(df2, aes(y = fct_rev(wday), 
                x= week, 
                fill = change_3)) +
  geom_tile(colour = "white") +
  scale_fill_gradient(low = "#BAE177", high ="#155219")
  

```

```{r}

ggplot(df2, aes(y = fct_rev(wday),
                x= week, fill = change_3)) +
  geom_tile(colour = "white") +
  #dodaję skalę kolorów a'la github na podstawi kolorymetru i funkcji rgb
  scale_fill_gradient(low = "#BAE177",
                      high ="#155219") +
  #coord_equal sprawia że rysują się kwadraty a nie prostokąty
  coord_equal() +
  theme_minimal()
  

```

```{r}

ggplot(df2, aes(y = fct_rev(wday),
                x= week, fill = change_3)) +
  geom_tile(colour = "white") +
  #dodaję skalę kolorów a'la github na podstawi kolorymetru i funkcji rgb
  scale_fill_gradient(low = "#BAE177",
                      high ="#155219") +
  #poniższa funkcja sprawia że rysują się kwadraty a nie prostokąty
  coord_equal() + 
  theme_minimal() +
  facet_wrap(~year, nrow =2)
  

```

```{r}

ggplot(df2, aes(y = fct_rev(wday),
                x= week, fill = change_3)) +
  geom_tile(colour = "white") +
  #dodaję skalę kolorów a'la github na podstawi kolorymetru i funkcji rgb
  scale_fill_gradient(low = "#BAE177",
                      high ="#155219") +
  #poniższa funkcja sprawia że rysują się kwadraty a nie prostokąty
  coord_equal() + 
  theme_minimal() +
  facet_wrap(~year, nrow = 2)

  
```

```{r}
miesiące = as.data.frame(table(df2$month))
```

```{r}

(y <- ggplot(df2, aes(y = fct_rev(wday),
                x= week, fill = change_3)) +
  geom_tile(colour = "white") +
  #dodaję skalę kolorów a'la github na podstawi kolorymetru i funkcji rgb
  scale_fill_gradient(low = "#BAE177",
                      high ="#155219",
                      na.value = "gray88") +
  #poniższa funkcja sprawia że rysują się kwadraty a nie prostokąty
  coord_equal() + 
  scale_x_continuous(breaks = seq(from =2.5, to = 52, by = 4.333),
                 labels = miesiące$Var1) +
  theme_minimal() +
  facet_wrap(~year, nrow = 2)
)

  
```

```{r}
library(plotly)
```

```{r, eval = FALSE}

ggplotly(y)
```



Stworzymy kalendarz wzorowany na kalendarzu aktywności na [githubie](https://www.louisahsmith.com/posts/2018-09-25-github-style-calendar-heatmap/).

Dane dotyczące ataków powietrznych na Ukrainę z [Kaggle](https://www.kaggle.com/datasets/piterfm/massive-missile-attacks-on-ukraine). Według opisu automatycznie ekstraktowane z komunikatów ukraińskich.

```{r}

# zbiór missile_attacks z kaggle

ataki_rakietowe <- read_csv("https://raw.githubusercontent.com/Tomasz-Olczyk/wizualizacjaR/main/czas/missile_attacks_daily.csv")


#zbiór missiles_and_uav 
środki <- read_csv("https://raw.githubusercontent.com/Tomasz-Olczyk/wizualizacjaR/main/czas/missiles_and_uav.csv")

```

```{r}

ataki <- ataki_rakietowe %>% 
  select(time_end, model,launched, destroyed) %>%
  mutate(date = as.Date(time_end)) %>%
  complete(date = seq.Date(as.Date("2022-01-01"), 
                           as.Date("2023-12-31"), 
                           by="day")) %>% 
  mutate(year = year(date),
         month = month(date, label = TRUE),
         months = month(date, label = FALSE),
         wday = wday(date, label = TRUE),
         day = day(date), 
         week = lubridate::isoweek(date)) 

```

Łączymy ramkę danych z ramką opisującą typy środków napadu powietrznego żeby wyselekcjonować ataki z użyciem wybranego typu:


```{r}

```

```{r}
ataki <- left_join(df3, środki)
```

```{r}
df4 <- df3 %>%
  filter(category == "cruise missile") %>%
 group_by(date) %>%
  summarise(wystrzelone = sum(launched)) %>%
  ungroup()

df3 <- left_join(df3, df4)
```

To będzie trzeba uporządkować może najpierw połączyć z typami pocisków a potem sklejać to dalj

```{r}

df5 <- df3 %>%
  distinct(date, .keep_all = TRUE)

```

```{r}
(y <- ggplot(df5, aes(y = fct_rev(wday),
                x= week, fill = wystrzelone)) +
  geom_tile(colour = "white") +
  #dodaję skalę kolorów a'la github na podstawi kolorymetru i funkcji rgb
  scale_fill_gradient(low = "#BAE177",
                      high ="#155219",
                      na.value = "gray88") +
  #poniższa funkcja sprawia że rysują się kwadraty a nie prostokąty
  coord_equal() + 
  scale_x_continuous(breaks = seq(from =2.5, to = 52, by = 4.333),
                 labels = miesiące$Var1) +
  theme_minimal() +
  facet_wrap(~year, nrow = 2)
)

  
```

Tylko cruise

```{r}

df4 %>%
  complete(date = seq.Date(as.Date("2022-01-01"), as.Date("2023-12-31"), by="day")) %>% 
  mutate(year = year(date),
         month = month(date, label = TRUE),
         months = month(date, label = FALSE),
         wday = wday(date, label = TRUE),
         day = day(date), 
         week = lubridate::isoweek(date))  -> df6 

```

```{r}
 ggplot(df6, aes(y = fct_rev(wday),
                x= week, fill = wystrzelone)) +
  geom_tile(colour = "white", 
            linewidth = 1) +
  #dodaję skalę kolorów a'la github na podstawi kolorymetru i funkcji rgb
  scale_fill_gradient(low = "#BAE177",
                      high ="#155219",
                      na.value = "gray88") +
  #poniższa funkcja sprawia że rysują się kwadraty a nie prostokąty
  coord_equal() + 
  scale_x_continuous(breaks = seq(from =1.5, to = 52, by = 4.333), labels = miesiące$Var1,
                     position = "bottom") +
  theme_minimal() +
  facet_wrap(~year, nrow = 2) +
   theme(panel.grid = element_blank(),
         axis.title.y = element_blank(),
         axis.title.x = element_blank(),
         legend.position = "bottom",
         legend.justification = "right") +
   guides(fill = guide_legend(title.position = "left", 
                              label.position = "bottom",
                              keywidth = 1, 
                              nrow = 1))


  
```

